[TOC]

# 0. 大纲

[导学](#导学)

[商场促销——策略模式](#商场促销——策略模式)



# 一. 导学

### 1. 好程序

* 特点
  * 可维护性（可读，好理解，修改方便）
  * 可扩展性（容易在其基础上扩展新功能）
  * 可复用性
  * 灵活性好
* 可复用!=可复制
  * 业务逻辑与界面逻辑分开，模块化，降低耦合度。才是可复用
* **编程是一门技术，更加是一门艺术** ，**不能只满足于写完代码运行结果正确就完事，时常考虑如何让代码更加简练，更加容易维护，容易扩展和复用，只有这样才可以真正得到提高**。写出优雅的代码真的是一种很爽的事情

### 2. UML图示

##### 1. 类

* 图示
  * ![类.PNG](https://upload-images.jianshu.io/upload_images/8438096-d5826fe0429d1427.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 特征
  * 矩形框
  * 三层
    * 一层类名，抽象类用斜体表示
    * 二层类特性，常为字段和属性
    * 三层方法，行为。
  * \+ public  -  private #  protected

##### 2. 接口图

* 图示
  * ![接口图.PNG](https://upload-images.jianshu.io/upload_images/8438096-036cc754575a115f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 特征
  * 如图

##### 3. 类之间，类与接口之间的关系

* 继承
  * <img src="https://upload-images.jianshu.io/upload_images/8438096-c72a4188a2389b22.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继承.PNG" style="zoom:50%;" />
* 实现接口
  * ![实现接口.PNG](https://upload-images.jianshu.io/upload_images/8438096-0676d3567d793b11.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 关联
  * ![关联关系.PNG](https://upload-images.jianshu.io/upload_images/8438096-889a8f7fe81acf4a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  * 一个类知道另一个类
* 聚合关系
  * <img src="https://upload-images.jianshu.io/upload_images/8438096-0effb587315340f7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="聚合关系.PNG" style="zoom:50%;" />
  * 大雁是群居动物，每只大雁都是属于一个雁群，一 个雁群可以有多只大雁。所以它们之间就满足聚合（Aggregation）关系。**聚合表示一种弱的‘拥 有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分** 
* 合成（组合）关系
  * ![合成关系.PNG](https://upload-images.jianshu.io/upload_images/8438096-7f5ce88b484e1e67.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
  * **“合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样** 
  * 在这里鸟和其翅膀就是合成（组合）关系， 因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。合成关系用实心的菱形+实线 箭头来表示。另外，**你会注意到合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。** 表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实 例，则就用‘n’来表示。关联关系、聚合关系也可以有基数的。”
* 依赖关系
  * ![依赖关系.PNG](https://upload-images.jianshu.io/upload_images/8438096-e6dd68aa8912687d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 二. 商场促销——策略模式

### 0. 前言

* 面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象， 具有相同属性和功能的对象的抽象集合才是类。

### 1. 简单工厂模式

* 针对一个易维护，易扩展，易复用，灵活性好的程序。比如说商场促销，会有许多处理不同促销方式的类。针对某一次特定的消费情况，如何选择相应的促销类就是一个问题。也就是如何选择实例化那个促销类是一个问题。
* 沙比办法就是if else或switch，好一点的办法就是简单工厂模式，把选择实例化那个促销类的过程封装在一个工厂类内。不错。
* 但是也带来问题，每多一种促销方式，或者同一种大促销方式但是改了初始条件，比如1,2,3,4折，每多一种促销方式都需要在工厂中加上。简单工厂模式虽然也能解决这些加促销方式或者促销类问题，但这个模式只是解决对象的创建问题，而且由于**工厂本身包括了所有的收费方式**，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个 工厂，以致代码需重新编译部署，这真的是很糟糕的处理方式，所以用它不是最好的办法
* 注：
  * 促销类指不同的大促销方式，比如满减或打折。
  * 促销方式指的是同一种促销类（大促销方式）有不同的促销方式，比如同样是折扣，有1,2,3折等等。显然虽说是同一个促销类，但是要增加一种促销方式的话虽说不用增加促销类，但是得在简单工厂中增加这个促销方式。

### 2. 策略模式（Strategy)

* ##### 定义

  * 它定义了算法（策略或者说是业务规则）家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。

* ##### 解析

  * 策略模式是一种定义一系列算法的方法，从概念上来 看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的 算法，减少了各种算法类与使用算法类之间的耦合[DPE] 
  * 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有 助于析取出这些算法中的公共功能[DP] 
  * 策略模式的优点是简化了单元测试，因为每个算法都有自己的 类，可以通过自己的接口单独测试[DPE] 
  * 当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以**在使用这些行为的类**中消除条件语句[DP] 
  * 策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性[DPE] 
  * 在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象[DPE] （这本身并没有解除客户端需要选择判断的压力，而策略模式与简单工厂模式结合后，选择具体实现的职责也可以由Context来承担，这就最大化地减轻了 客户端的职责。）

# 三. 拍摄UFO-单一职责原则

### 0. 前言

* ​    我们在做编程的时候，很自然 地就会给一个类加各种各样的功能，比如我们写一个窗体应用程序， 一般都会生成一个Form1这样的类，于是我们就把各种各样的代码， 像某种商业运算的算法呀，像数据库访问的SQL语句呀什么的都写到 这样的类当中，这就意味着，无论任何需求要来，你都需要更改这个 窗体类，这其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活 性。”

### 1. 单一职责原则（SRP Single responsibility principle)

* ##### 定义

  * 就一个类而言，应 该仅有一个引起它变化的原因[ASD] 

* ##### 解析

  * 如果一个类承担的职责过多， 就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制 这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发 生时，设计会遭受到意想不到的破坏[ASD] 
  * **软件设计真正要做的许多内容，就是发现职责并把那些职 责相互分离[ASD]** 。其实要去判断是否应该分离出类来，也不难，那就是**如果你能够想到多于一个的动机去改变一个类，那么这个类就具 有多于一个的职责[ASD]** ，**就应该考虑类的职责分离**

* ##### 总之

  * 编程时，我们要在类的职责分离上多思考，做到单一职 责，这样你的代码才是真正的易维护、易扩展、易复用、灵活多样。”

* ##### 个人理解

  * 其实这是整合或者分离思想在程序领域的体现。跟生活中一样，整合的好处是方便，一个人可以用干很多事，各个职责共存于一个整体，所以它们的协作通信成本低，协作效果非常好。但是负面影响就是不容易替换某个职责，或者说某个职责出问题会影响整体，还有就是很难每个职责都做到最顶尖。相反，分离的好处就是每个职责可以做到更顶尖，而且某个职责出问题容易替换，不容易影响整体。但是坏处就是加大了协作难度和开销。
  * 就程序设计而言，整合界面简单，逻辑简单，效率高，开销小。但是修改，维护，扩展方面开销大。分离成许许多多单一职责的类的话，易修改，易维护，易扩展，灵活性好。但是带来了极大的协作成本，比如各种类的创建，沟通。这就要折中看水平了。

# 四. 考研求职两不误-开放封闭原则

### 0. 前言

* 类似香港回归，大陆既不能改社会主义，香港也不能改资本主义。在软件设计模式中， 这种不能修改，但可以扩展的思想也是最重要的一种设计原则，它就 是开放-封闭原则（The Open-Closeed Principle，简称OCP）或叫开-闭 原则。”
* 我们在做任何系统的时候，都不要指望系统一开始时需求 确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是 一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对 容易修改，不至于说，新需求一来，就要把整个程序推倒重来。**怎样 的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以 在第一个版本以后不断推出新的版本呢？[ASD] ，开放-封闭给我们答 案。**”

### 1. 开放封闭原则（OCP   Open-Closed Principle)

* ##### 定义

  * 软件实体（类，模块，函数等）应该可以扩展，但是不可修改。

* ##### 特征

  * 对于扩展是开放的（Open for extension),对于更改是封闭的（Closed for modification)

* ##### 解析

  * 开放-封闭原则的意思就是说，你设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。
  * 无论模块是 多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全 封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离 那些变化[ASD] 。”
  * 在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就**创建抽象来隔离以后发生的同类变化[ASD]** （商场促销的方案，最一开始设计的时候只假设有打折和满减两种方案，一股脑把他写入了客户端一个类中。但是后来发现，如果新增一个折扣方案，就得修改编译整个客户端类，不方便。于是我们马上行动全力，创建策略模式这个抽象，这样以后面对同类的需求，我们只需扩展无需修改。设计代码时我们只能尽量设想需求，然后设计抽象来封闭修改，开放扩展，但是计划赶不上，永远有你想不到的需求，这就要求我们新需求一来。马上采取行动，建立抽象，以后对于同类需求，就可以游刃有余的扩展了。也就是说不要在同一个地方跌倒两次。即**面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码 [ASD] 。这就是‘开放-封闭原则’的精神所在。”**）
  * **当然，并不是什么时候应对变化都是容易的。我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难[ASD] **
  * “开放-封闭原则是面向对象设计的核心所在。遵循这个原 则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩 展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的 那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行 抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要 

# 五. 会修电脑不会修收音机？----依赖倒置原则

### 0. 前言

* 高内聚，低耦合
  * 从模块粒度来看，高内聚：尽可能类的每个成员方法只完成一件事（最大限度的聚合）； 低耦合：减少类内部，一个成员方法调用另一个成员方法。从类角度来看， 高内聚低耦合：减少类内部，对其他类的调用；从功能块来看 高内聚低耦合：减少模块之间的交互复杂度（接口数量，参数数据）即横向：类与类之间、模块与模块之间；纵向：层次之间；尽可能，内容内聚，数据耦合
* **里氏代换原则**
  * 定义
    * 子类型必须能够替换掉它们的父类型
  * 通俗
    * 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且 它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把 父类都替换成它的子类，程序的行为没有变化， 简单地说，子类型必 须能够替换掉它们的父类型[ASD]。”

### 1. 依赖倒置原则

* ##### 定义

  * 高层模块不应该依赖底层模块。两个都应该依赖抽象
  * 抽象不应该依赖细节。细节应该依赖抽象
  * (具体来说，抽象就是接口或者或者说是抽象类)

* ##### 解析

  * 所谓里氏代换原则，核心就是一句话，所有父类能出现的地方，那么子类也能出现。这样带来了一个极大的好处：正因为有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
  * 由于子类型的可替换性才使得使用父类类 型的模块在无需修改的情况下就可以扩展
  * 依赖倒转其实可以说是面向对象设计的标志，用哪 种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了[ASD] 。”

* ##### 总结

  *  首先上面的抽象，具体一点就是接口或者说是抽象类。
  * 举个例子，过程化设计中，针对实现编程。比如说一个利用数据库的软件。数据库部分属于底层模块，它针对实现设计，就是如何实现数据库的功能，然后给出使用接口。于是针对某一个功能的使用数据的逻辑写一个高层模块，这个高层模块利用接口使用这个数据库。
  * 这就是典型的高层模块依赖底层模块。
  * 此时，因为某些原因要更换数据库，但是使用数据的方式是不变的，也就是说高层模块完全可以复用，但是因为数据库变了，接口变了，高层模块就得改。
  * 所以说依赖倒置原则就出现了，就是说软件在设计之初高层模块和底层模块只依赖于抽象去实现。这个抽象定义了高层使用底层数据库的方式。这样先设计一个抽象类或者接口，底层和高层都依赖于这个抽象。那么根据里氏代换原则，如果要换底层，因为底层依赖于抽象，通俗来讲，此处的抽象相当于父类，底层相当于子类。
  * 根据里氏代换原则，所有父类出现的地方，子类都可以出现。所以如果所有的底层都依赖于这个抽象设计，那么就可以随便换底层，高层一行代码都不需要高。面向过程的精髓就在于此。同理，高层也是这样，只要这个借口或者抽象类定义好了，上下层可以特别方便的替换，扩展等等。

# 六. 穿什么有这么重要？——装饰模式

### 0. 前言

* 建造者模式要求建造的过程必须是稳定的，而现在我们 这个例子，建造过程是不稳定的，比如完全可以内穿西装，外套T 恤，再加披风，打上领带，皮鞋外再穿上破球鞋；当然也完全可以只 穿条裤衩就算完成。换句话就是说，通过服饰组合出一个有个性的人 完全可以有无数种方案，并非是固定的。”
  “啊，你说得对，其实先后顺序也是有讲究的，如你所说，先穿内裤后穿外裤，这叫凡人，内裤穿到外裤外面，那就是超人
* **需要把所需的功能按正确的顺序串联起来进行控制**

### 1. 装饰模式（Decorator）

* ##### 定义

  * 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

### 